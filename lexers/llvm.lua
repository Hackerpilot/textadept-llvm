local l = require('lexer')
local token, word_match = l.token, l.word_match
local P, R, S = lpeg.P, lpeg.R, lpeg.S

local M = {_NAME = 'llvm'}

-- Whitespace.
local ws = token(l.WHITESPACE, l.space^1)

local comment = token(l.COMMENT, ';' * l.nonnewline_esc^0)

local identifier = token(l.CLASS, P('%') * l.word)

local keywords = token(l.KEYWORD, word_match{
'acq_rel',
'acquire',
'addrspace',
'alias',
'align',
'alignstack',
'alwaysinline',
'any',
'appending',
'arcp',
'argmemonly',
'asm',
'attributes',
'available_externally',
'builtin',
'byval',
'call',
'cold',
'comdat',
'common',
'constant',
'convergent',
'datalayout',
'declare',
'define',
'dereferenceable',
'dereferenceable_or_null',
'dllexport',
'dllimport',
'exactmatch',
'external',
'extern_weak',
'fast',
'gc',
'getelementpointer',
'global',
'inaccessiblememonly',
'inaccessiblemem_or_argmemonly',
'inalloca',
'inbounds',
'initial',
'initialexec',
'inlinehint',
'inreg',
'internal',
'jumptable',
'largest',
'linkonce',
'linkonce_odr',
'load',
'localdynamic',
'localexec',
'metadata',
'minsize',
'module',
'monotonic',
'naked',
'nest',
'ninf',
'nnan',
'noalias',
'nobuiltin',
'nocapture',
'noduplicate',
'noduplicates',
'noimplicitfloat',
'noinline',
'nonlazybind',
'nonnull',
'norecurse',
'noredzone',
'noreturn',
'nounwind',
'nsz',
'null',
'optnone',
'optsize',
'personality',
'prefix',
'private',
'prologue',
'readnone',
'readonly',
'release',
'ret',
'returned',
'returns_twice',
'safestack',
'samesize',
'sanitize_address',
'sanitize_memory',
'sanitize_thread',
'select',
'seq_cst',
'signext',
'singlethread',
'sret',
'ssp',
'sspreq',
'sspstrong',
'target',
'triple',
'type',
'undef',
'unordered',
'uwtable',
'weak',
'weak_odr',
'zeroext',
})

local ints = token(l.TYPE, P('i') * l.digit^1)
local floats = token(l.TYPE, word_match{'half',
'float',
'double',
'fp128',
'x86_fp80',
'ppc_fp128',
'x86_mmx',
})
local types = ints + floats + token(l.TYPE, 'void')

local constants = token(l.NUMBER, l.float + l.dec_num)
	+ token(l.NUMBER, word_match{'true', 'false', 'null', 'none'})

local instructions = token(l.OPERATOR, word_match{
'addrspacecast',
'alloca',
'and',
'ashr',
'atomicrmw',
'bitcast',
'call',
'catchpad',
'cleanuppad',
'cmpxchg',
'extractelement',
'extractvalue',
'fcmp',
'fence',
'fpext',
'fpoui',
'fptosi',
'fptrunc',
'getelementptr',
'icmp',
'insertelement',
'insertvalue',
'inttoptr',
'landingpad',
'load',
'lshr',
'or',
'phi',
'ptrtoint',
'select',
'sext',
'shl',
'shufflevector',
'sitofp',
'store',
'to',
'trunc',
'uitofp',
'va_arg',
'xor',
'zext',
})

local operators = token(l.OPERATOR, S('?=!<>+-*$/%&|^~.,;()[]{}')) + instructions

M._rules = {
	{'whitespace', ws},
	{'comment', comment},
	{'keyword', keywords},
	{'type', types},
	{'constant', constants},
	{'identifier', identifier},
	{'operator', operators},
}

M._tokenstyles = {}
M._foldsymbols = {
  _patterns = {'[{}]', '/[*+]', '[*+]/', '//'},
  [l.OPERATOR] = {['{'] = 1, ['}'] = -1},
}

return M
